#+title: GNU Emacs configuration/distribution
#+author: Klementiev Dmitry
#+email: klementievd08@yandex.ru

Main goals of this distribution:
- Convenient navigation through the =Emacs.org=
- Fast startup (also with Org Babel)
- Good Emacs Lisp code. Keep it simple to read and maintain
- Only a few packages are loaded at startup (lazy-loading)
- No =use-package= macro. You know what you're doing.
- Excellent terminal support (=emacs -nw=)


Other files:
- [[file:early-init.el][Early Initialization file]]

  Main optimizations of GNU Emacs.

- [[file:init.el][Initialization file]]

  Bootstrap Elpaca and load Org Babel files.


Use lexical-binding. (for byte-compilation)
#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t; -*-
#+end_src

* Table Of Contents :TOC:
- [[#functions-and-macroses][Functions and Macroses]]
  - [[#after-macro][=after!= macro]]
  - [[#require-on-macro][=require-on!= macro]]
  - [[#autoload-macro][=autoload!= macro]]
- [[#basic-emacs][Basic Emacs]]
- [[#uiux][UI/UX]]
  - [[#theme][Theme]]
  - [[#hl-todo-highlight-todos][HL-TODO (Highlight TODOs)]]
  - [[#awesome-tray][Awesome Tray]]
  - [[#initial-screen-dashboard][Initial Screen (Dashboard)]]
  - [[#golden-ratio-for-emacs-windows][Golden Ratio for Emacs windows]]
  - [[#tab-bar-mode][Tab Bar mode]]
- [[#navigation][Navigation]]
  - [[#which-key][Which-key]]
  - [[#hydra][Hydra]]
  - [[#vertico][Vertico]]
  - [[#marginalia][Marginalia]]
  - [[#consult][Consult]]
  - [[#embark][Embark]]
  - [[#avy][Avy]]
  - [[#ace-window][Ace-Window]]
- [[#editing][Editing]]
  - [[#smartparens][Smartparens]]
  - [[#git-gutter][Git-Gutter]]
  - [[#tree-sitter][Tree-Sitter]]
- [[#completion][Completion]]
  - [[#orderless][Orderless]]
  - [[#corfu][Corfu]]
- [[#org-mode][Org Mode]]
  - [[#main-settings][Main Settings]]
  - [[#planning-agenda][Planning (Agenda)]]
- [[#development][Development]]
  - [[#vcs-magit-forge-git-modes][VCS (Magit, Forge, Git-Modes)]]
  - [[#repl-eat-eshell][REPL (Eat, Eshell)]]
  - [[#languages][Languages]]

* Functions and Macroses

Набор функций и макросов для конфигурации.

** =after!= macro

Более удобная и лучшая версия =with-eval-after-load=.

#+begin_src emacs-lisp
  (defmacro after! (packages &rest body)
    (declare (indent defun))
    (let ((packages (eval `(,@packages))))
      (cond ((not packages)
             `(progn
                ,@body))
            ((symbolp packages)
             `(with-eval-after-load ',packages
                ,@body))
            ((listp packages)
             `(with-eval-after-load ',(car packages)
                (after! ',(cdr packages)
                  ,@body))))))
#+end_src

** =require-on!= macro

Предоставляет возможность подгружать пакет при использовании хука или комманды.

По факту это добавляет хук или "advice" который запускается лишь единожды, подгружая пакет.

#+begin_src emacs-lisp
  (defun require-on-hook (hook package)
    (let ((fnname (intern (concat "load-" (prin1-to-string package)
                                  "-on-" (prin1-to-string hook)))))
      `(when (boundp ',hook)
         ,(unless (fboundp fnname)
            `(defun ,fnname (&rest _)
               (require ',package)
               (remove-hook ',hook #',fnname)))
         (add-hook ',hook #',fnname))))

  (defun require-on-command (command package)
    (let ((fnname (intern (concat "load-" (prin1-to-string package)))))
      (when (fboundp command)
        `(define-advice ,command
             (:before (&rest _) ,fnname)
           (advice-remove ',command #',(intern (concat (prin1-to-string command)
                                                       "@" (prin1-to-string fnname))))
           (require ',package)))))

  (defmacro require-on! (symbol package)
    "Load PACKAGE on SYMBOL."
    (declare (indent nil))
    (cond
     ((commandp symbol)
      (require-on-command symbol package))
     ((boundp symbol)
      (require-on-hook symbol package))
     (t (error "Can't determine symbol for require-on!: %s" symbol))))
#+end_src

** =autoload!= macro

Удобный макрос для ленивой загрузки. В отличие от обычной функции =autoload= можно загружать
несколько функций одним вызовом макроса (в целом это и есть всё удобство).

#+begin_src emacs-lisp
  (defun autoload! (package &rest autoloads)
    "Generate AUTOLOADS from PACKAGE by repeating `autoload' function."
    (declare (indent defun))
    (dolist (symbol autoloads)
      (cond ((listp symbol)
             (pcase-let* ((`(,symbol ,doc-string ,interactive?) symbol))
               (autoload symbol package doc-string interactive?)))
            ((symbolp symbol)
             (autoload symbol package))
            (t (error "Can't determine symbol type for autoloading with `autoload!' macro")))))
#+end_src

* Basic Emacs

#+begin_src emacs-lisp
  (defun load-my-custom-file ()
    (load custom-file :no-error :no-message :no-suffix :must-suffix))

  (after! 'emacs
    (add-hook 'elpaca-after-init-hook #'load-my-custom-file)

    (setq frame-title-format "GNU Emacs"
          make-backup-files nil
          custom-file (expand-file-name "custom.el" user-emacs-directory)
          cursor-type 'box
          ;; cursor-type '(bar . 2)
          cursor-in-non-selected-windows nil
          default-input-method "russian-computer"
          indent-tabs-mode nil
          tab-width 4)

    (blink-cursor-mode 1)
    (add-hook 'text-mode-hook 'visual-line-mode)
    (add-hook 'prog-mode-hook 'visual-line-mode))

  (eval-when-compile
    (require 'recentf)
    (require 'fringe))

  (after! 'recentf
    (recentf-mode 1))

  (after! 'fringe
    (fringe-mode '(8 . 8)))
#+end_src

* UI/UX

*Настройка UI/UX.*

Данная часть конфигурации подразумевает в себе не только красивый и приятный глазу внешний вид,
но и удобный, интуитивный интерфейс.

** Theme

Мне очень нравится обычная тема из Doom Emacs. Она слишком хороша собой :)

#+begin_src emacs-lisp
  (defvar default-theme 'doom-one
    "Default theme for GNU Emacs.

  1. Autoload `default-theme' from theme-package
  2. Load theme")

  (elpaca 'doom-themes
    (autoload! "doom-themes"
      default-theme)

    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                    (with-selected-frame frame
                      (load-theme default-theme :no-confirm))))
      (add-hook 'elpaca-after-init-hook
                (lambda ()
                  (load-theme default-theme :no-confirm)))))
#+end_src

** HL-TODO (Highlight TODOs)

TODO: Add *PERF* keyword
TODO: ADD *BUG* keyword

#+begin_src emacs-lisp
  (setq-default hl-todo-require-punctuation t
  	      hl-todo-highlight-punctuation ":")

  ;; TODO: Move nerd-icons from the hl-todo
  ;; PERF: No lazy loading.
  ;;   Nerd-Icons loaded at startup time
  (elpaca 'nerd-icons
    (eval-when-compile
      (require 'nerd-icons)))

  (elpaca 'hl-todo
    (autoload! "hl-todo"
      'hl-todo-mode)
    (add-hook 'text-mode-hook 'hl-todo-mode)
    (add-hook 'prog-mode-hook 'hl-todo-mode))

  (after! 'hl-todo
    (add-hook 'hl-todo-mode-hook
  	    (lambda ()
  	      (unless hl-todo-mode
  		(remove-overlays nil nil 'hl-todo t))))
    (add-to-list 'hl-todo--keywords `(,(lambda (bound) (remove-overlays (point) bound 'hl-todo t) nil))))

  (after! '(hl-todo nerd-icons)
    (define-advice hl-todo--get-face
        (:override () with-icons)
      (let* ((keyword (match-string 2))
             (ov (make-overlay (match-beginning 0) (match-end 0))))

        ;; Overlays only for the icons
        (overlay-put ov 'hl-todo t)
        (overlay-put ov 'evaporate t)
        (overlay-put ov 'before-string
                     (pcase keyword
                       ("TODO" (nerd-icons-sucicon "nf-seti-todo"))
                       ("TEMP" (nerd-icons-mdicon "nf-md-timer"))
                       ("BUG" (nerd-icons-faicon "nf-fa-bug"))
                       ("FIXME" (nerd-icons-faicon "nf-fa-wrench"))
                       ("WARNING" (nerd-icons-faicon "nf-fa-flag"))
                       (_ (nerd-icons-mdicon "nf-md-content_paste"))))

        ;; Return color for font-lock
        (hl-todo--combine-face
         (cdr (or
               ;; Fast allocation free lookup for literal keywords.
               (assoc keyword hl-todo-keyword-faces)
               ;; Slower regexp lookup.
               (compat-call assoc keyword hl-todo-keyword-faces
                            (lambda (a b)
                              (string-match-p (format "\\`%s\\'" a) b)))))))))
#+end_src

** Awesome Tray

Мне больше нравится минималистичный трэй, чем строка состояния на подобии Doom Modeline. Достаточно одной небольшой строчки со всей необходимой мне информацией.

#+begin_src emacs-lisp :no-export
  (setq-default awesome-tray-hide-mode-line t
                awesome-tray-update-interval 0.2
                ;; For Doom One theme
                awesome-tray-mode-line-active-color "violet")

  (elpaca '(awesome-tray
            :host github
            :repo "manateelazycat/awesome-tray")
    (autoload! "awesome-tray"
      'awesome-tray-mode)
    
    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                    (with-selected-frame frame
                      (awesome-tray-enable)))
                  200)
      (add-hook 'elpaca-after-init-hook 'awesome-tray-mode 200)))

  (after! '(awesome-tray org-timer)
    (setq org-timer-display nil)          ; Don't display `org-timer'
                                          ; in unexistent mode-line
    
    (defun org-timer-module ()
      (if org-timer-active
          (org-timer-value-string)
        nil))

    (defface org-timer-module-face
      '((t (:bold t)))
      "Org Timer module face."
      :group 'awesome-tray)

    (add-to-list 'awesome-tray-module-alist
                 '("org-timer" . (org-timer-module org-timer-module-face)))
    (add-to-list 'awesome-tray-active-modules "org-timer"))
#+end_src


** Initial Screen (Dashboard)

В качестве начального экрана есть два пакета:
- =dashboard= - Максимально простой и готов к использованию
- =enlight= + =grid= - Очень глубокая кастомизация (сложен в настройке)

Пока что я выберу Dashboard, и не буду париться о том, что и как нужно
делать.

#+begin_src emacs-lisp
  (setq-default dashboard-center-content t
                dashboard-vertically-center-content nil
                dashboard-items '((recents . 10)
                                  (bookmarks . 3)
                                  (projects . 3)
                                  (agenda . 5)))
  (elpaca 'dashboard
    (autoload! "dashboard"
      'dashboard-setup-startup-hook)
    (dashboard-setup-startup-hook))

  (with-eval-after-load 'dashboard
    (add-hook 'dashboard-mode-hook 'visual-line-mode)

    ;; Open dashboard when using "emacsclient -c" (daemon only)
    (when (daemonp)
      (setq initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name))))

    (defun my/dashboard-init--info ()
      (format "%d packages installed. %d packages loaded. Emacs started in %s"
              (dashboard-init--packages-count)
              external-packages-loaded-count
              (dashboard-init--time)))

    (setq dashboard-init-info #'my/dashboard-init--info))
#+end_src

** Golden Ratio for Emacs windows

#+begin_src emacs-lisp
  (elpaca 'golden-ratio
    (require-on! split-window-below
                 golden-ratio)

    (require-on! split-window-right
                 golden-ratio))

  (after! 'golden-ratio
    (golden-ratio-mode 1)
    (add-to-list 'golden-ratio-extra-commands 'ace-window))
#+end_src

** Tab Bar mode

#+begin_src emacs-lisp
  (autoload! "tab-bar"
    '(tab-bar-mode nil t))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame
                    (tab-bar-mode 1))))
    (add-hook 'emacs-startup-hook 'tab-bar-mode))
#+end_src

* Navigation

*Навигация*

Данный заголовок включает в себя не только навигацию в тексте.

Вот что подразумевается под *навигацией*:
- Навигация в буффере/тексте
- Перемещение между буфферами (=consult-buffer=)
- Перемещение между окнами
- Навигация между сочетаниями клавиш (соответственно их конфигурация: which-key, hydra, и.т.д)
- Навигация в минибуффере и между коммандами (vertico, embark, consult)

** Which-key

#+begin_src emacs-lisp
  (if after-init-time
      (which-key-mode 1)
    (add-hook 'after-init-hook 'which-key-mode))
#+end_src

** Hydra

#+begin_src emacs-lisp
  ;; FIXME: Byte-Compilation throw error when using `defhydra'
  ;;   out of `elpaca' macro. All `defhydra' usage are written
  ;;   in `elpaca' usage for `hydra' package.
  ;; PERF: Hydra loaded at startup time.
  ;; TODO: Improve Hydra configuration.
  ;;   It throw errors out of `elpaca' macro when byte-compiling.
  ;;   Also it loads at startup time. (No lazy loading)
  (elpaca 'hydra
    (require 'hydra)
    
    (defhydra hydra-zoom ()
      "Zoom"
      ("i" text-scale-increase "in")
      ("d" text-scale-decrease "out"))
    (bind-key "<f2>" 'hydra-zoom/body)
    
    (defhydra hydra-org-timer ()
      "Org Timer"
      ("s" org-timer-start "Start timer")
      ("e" org-timer-stop "Timer end (Stop timer)")
      ("p" org-timer-pause-or-continue "Pause/Continue timer")
      ("t" org-timer-set-timer "Set timer")
      ("q" nil "Quit"))
    (bind-key "o t" 'hydra-org-timer/body mode-specific-map))
#+end_src

** Vertico

#+begin_src emacs-lisp
  (elpaca 'vertico
    (require-on! pre-command-hook
                 vertico))

  (after! 'vertico
    (vertico-mode 1))
#+end_src

** Marginalia

#+begin_src emacs-lisp
  (elpaca 'marginalia
    (after! 'vertico
      (require 'marginalia)))

  (after! 'marginalia
    (marginalia-mode 1))
#+end_src

** Consult

#+begin_src emacs-lisp
  (elpaca 'consult
    (eval-when-compile
      (require 'consult)))

  (with-eval-after-load 'consult
    (bind-keys ("s-B" . consult-buffer)
               ([remap switch-to-buffer] . consult-buffer)
               ("C-s" . consult-line)
               ("M-g g" . consult-goto-line)))
#+end_src

** Embark

#+begin_src emacs-lisp
  (elpaca 'embark
    (autoload! "embark"
      '(embark-act nil t)
      '(embark-dwim nil t)
      '(embark-bindings nil t))

    (bind-keys ("C-." . embark-act)          ; pick some comfortable binding
               ("C-;" . embark-dwim)         ; good alternative for M-.
               ("C-h B" . embark-bindings))) ; alternative for `describe-bindings'

  (after! 'embark
    ;; FIXME: `org-open-at-point-global' can't open link to heading (in TOC for example)
    ;;
    ;; I solve it just by replacing `org-open-at-point-global' by default
    ;; `org-open-at-point' function when current major mode is Org
    (define-advice org-open-at-point-global
        (:around (orig-fun) current-mode-is-org)
      (if (eq major-mode #'org-mode)
          (funcall #'org-open-at-point)
        (funcall orig-fun))))

  ;; Embark automatically load it after consult is found
  (elpaca 'embark-consult)

  (after! 'embark-consult
    (add-hook 'embark-collect-mode-hook 'consult-preview-at-point-mode))
#+end_src

** Avy

Для навигации в тексте есть множество плагинов:
- =avy= - Основной плагин (и пока что единственный используемый в конфиге)
- =ace-link= - Как =ace-window= или =avy=, но для ссылок
- и.т.д - TODO: Пакетов еще много, их стоит разобрать

Конфигурация =avy=.

TODO: Стоит посмотреть ещё комманды которые предоставляет =avy=. (Это слишком мощная штука)

#+begin_src emacs-lisp
  (elpaca 'avy
    (autoload! "avy"
      '(avy-goto-char-2 nil t))
    (bind-key* "C-'" 'avy-goto-char-2))
#+end_src

** Ace-Window

#+begin_src emacs-lisp
  (elpaca 'ace-window
    (autoload! "ace-window"
      '(ace-window nil t))
    (bind-key "M-o" 'ace-window))
#+end_src

* Editing

** Smartparens

Безальтернативный плагин для автоматического закрытия скобочек (и не только).

В целом данный плагин идеален для редактирования Lisp, Scheme и подобных им языков

#+begin_src emacs-lisp
  (defconst default-pairs-list
    '((?\( . ?\))
      (?\[ . ?\])
      (?\{ . ?\}))
    "List of default pairs")

  (defun open-pair-p (char)
    "Return t if CHAR is opening pair"
    (member char (mapcar (lambda (pairs) (car pairs)) default-pairs-list)))

  (defun close-pair-p (char)
    "Return t if CHAR is closing pair"
    (member char (mapcar (lambda (pairs) (cdr pairs)) default-pairs-list)))

  (defun indent-between-pairs ()
    "Open a new brace or bracket expression, with relevant newlines and indent."
    (interactive)
    (if (and (open-pair-p (char-before))
             (close-pair-p (char-after)))
        (progn (newline)
               (newline)
               (indent-according-to-mode)
               (forward-line -1)
               (indent-according-to-mode))
      (newline-and-indent)))

  (bind-key "RET" 'indent-between-pairs prog-mode-map)

  (elpaca 'smartparens
    (autoload 'smartparens-mode "smartparens")
    (autoload 'smartparens-strict-mode "smartparens")
    (add-hook 'prog-mode-hook 'smartparens-mode)
    (dolist (hook '(emacs-lisp-mode-hook
                    lisp-mode-hook
                    common-lisp-mode-hook
                    scheme-mode-hook))
      (add-hook hook 'smartparens-strict-mode)))

  (with-eval-after-load 'smartparens
    (require 'smartparens-config)
    (bind-keys :map smartparens-mode-map
               ("M-s" . nil)
               ("M-DEL" . sp-backward-unwrap-sexp)
               ("C-<left>" . sp-forward-barf-sexp)
               ("C-<right>" . sp-forward-slurp-sexp)))
               
#+end_src

** Git-Gutter

#+begin_src emacs-lisp
  (elpaca 'git-gutter
    (autoload 'git-gutter-mode "git-gutter")
    (add-hook 'prog-mode-hook 'git-gutter-mode)
    (add-hook 'text-mode-hook 'git-gutter-mode))
#+end_src

** Tree-Sitter

Tree Sitter в GNU Emacs - это головная боль. Местами он слишком сложен в настройке и просто работает каким-то вообще непонятным образом.

Для начала нужно определить простую функцию которая будет устанавливать грамматику для всех определённых языков.

#+begin_src emacs-lisp
  (defun treesit-install-all ()
    "Install all language grammars from `treesit-language-source-alist'
  variable by `treesit-install-language-grammar' function.

  This function install language grammar only when it unavailable."
    (interactive)
    (mapc
     (lambda (lang)
       (when (not (treesit-language-available-p lang))
         (treesit-install-language-grammar lang)))
     (mapcar #'car treesit-language-source-alist)))
#+end_src

Далее определяем языки (и их грамматику), а так же запускаем их установку.

#+begin_src emacs-lisp
  ;; Tree Sitter source
  (setq treesit-language-source-alist
        '((go "https://github.com/tree-sitter/tree-sitter-go")
          (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
          (c "https://github.com/tree-sitter/tree-sitter-c")
          (zig "https://github.com/maxxnino/tree-sitter-zig")
          (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
          (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
          ;; (yaml "https://github.com/ikatyang/tree-sitter-yaml")
          (python "https://github.com/tree-sitter/tree-sitter-python")
          (bash "https://github.com/tree-sitter/tree-sitter-bash")))

  (run-with-timer 1 nil 'treesit-install-all)
#+end_src

* Completion

** Orderless

#+begin_src emacs-lisp
  (elpaca 'orderless
    (require-on! self-insert-command
                 orderless))

  (after! 'orderless
    (setq completion-styles '(orderless basic)))
#+end_src

** Corfu

#+begin_src emacs-lisp
  (elpaca 'corfu
    (require-on! self-insert-command
                 corfu))

  (after! 'corfu
    (setq corfu-cycle t)
    (setq tab-always-indent 'complete)
    (global-corfu-mode 1)

    (require 'corfu-popupinfo)
    (corfu-popupinfo-mode 1)

    (bind-keys* :map corfu-map
                ("TAB" . corfu-complete)
                ("M-d" . corfu-popupinfo-toggle)
                :map corfu-popupinfo-map
                ("M-n" . corfu-popupinfo-scroll-up)
                ("M-p" . corfu-popupinfo-scroll-down)))
#+end_src

* Org Mode

** Main Settings

Навигация при помощи =consult-org-heading=.

#+begin_src emacs-lisp
  (after! '(org consult)
    (bind-keys :map org-mode-map
  	     ("C-s" . consult-org-heading)
  	     ("C-S-s" . consult-line)))
#+end_src

Лучшая настройка для таймера.

#+begin_src emacs-lisp
  (after! 'org-timer
    (setq org-timer-display nil)

    (defvar org-timer-active nil
      "Non-nil if org-timer is activated")

    (defun org-timer-activate ()
      "Set `org-timer-active' to t"
      (setq org-timer-active t))

    (defun org-timer-deactivate ()
      "Set `org-timer-active' to nil"
      (setq org-timer-active nil))

    (add-hook 'org-timer-start-hook 'org-timer-activate)
    (add-hook 'org-timer-stop-hook  'org-timer-deactivate)
    (add-hook 'org-timer-set-hook   'org-timer-activate)
    (add-hook 'org-timer-done-hook  'org-timer-deactivate))
#+end_src

Автоматическая генерация [[*Table Of Contents][TOC]].

#+begin_src emacs-lisp
  (elpaca 'toc-org
    (autoload 'toc-org-mode "toc-org")
    (add-hook 'org-mode-hook 'toc-org-mode))
#+end_src

** Planning (Agenda)

TODO: Использовать =org-super-agenda=

*** Кастомные комманды, виды (Custom commands, views)

**** Learning (Обучение)

Отдельный вид агенды для отслеживания и планирования задач, целей по изучению алгоритмов
и структур данных

#+begin_src emacs-lisp :tangle no :noweb-ref custom-agenda-views
  ("l" "Learning Agenda"
   ((agenda "" ((org-agenda-span 'day)
                (org-agenda-remove-tags t)
                (org-deadline-warning-days 7)
                ;; TODO: Filter by @yandexlearning tag instead of file
                (org-agenda-files '("~/org/agenda/YandexLearning.org"))))
    (tags-todo "+@yandexlearning+PRIORITY=\"A\"+SCHEDULED<=\"<today>\""
               ((org-agenda-span 'day)
                (org-agenda-remove-tags t)
                (org-agenda-overriding-header "High Priority Tasks")))
    (tags-todo "+@yandexlearning/TODO"
               ((org-agenda-tags-todo-honor-ignore-options t)
                (org-agenda-todo-ignore-scheduled t)
                (org-agenda-remove-tags t)
                (org-agenda-overriding-header "Just TODO Tasks")))))
#+end_src

**** Weekly Review (Недельный обзор)

Недельный обзор завершённых и оставшихся запланированных задач.

Неплохо посмотреть в конце недели как много ты проеб**нил :)

#+begin_src emacs-lisp :tangle no :noweb-ref custom-agenda-views
  ("w" "Weekly Review"
   ((agenda "" ((org-agenda-overriding-header "Completed Tasks")
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo 'done))
                (org-agenda-span 'week)))
    (agenda "" ((org-agenda-overriding-header "Unfinished Scheduled Tasks")
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                (org-agenda-span 'week)))))
#+end_src

*** Конфигурация

#+begin_src emacs-lisp :noweb yes :noweb-prefix no
  (setq-default org-agenda-custom-commands '(<<custom-agenda-views>>))
#+end_src

#+begin_src emacs-lisp
  (setq-default org-agenda-start-with-log-mode t
                org-log-done 'time
                org-log-into-drawer t)

  (define-advice org-agenda
      (:before (&rest _) update-files)
    (setq org-agenda-files
          (directory-files-recursively
           (expand-file-name "agenda" org-directory)
           "\\`[A-Za-z]*.org\\'")))

  (bind-key "a" 'org-agenda mode-specific-map)
#+end_src

* Development

** VCS (Magit, Forge, Git-Modes)

Git интеграция сводится в основном к двум плагинам: =magit= и =forge=.

=magit= - Незаменимый и безальтернативный Git интерфейс. Более мощного гит интерфейса вы просто не найдёте.

=forge= - Клиент для Github, Gitlab и других хостингов прямо в GNU Emacs.

Пока что я не устанавливаю Forge в своей конфигурации (он мне попросту не нужен, а так же я пишу её не
на своём устройстве). Зато мы сделаем конфиг для Git файлов (gitattributes, gitignore, gitsubmodules)
и настроим Magit, который будет показывать для нас TODOs (плагин =magit-todos=)

#+begin_src emacs-lisp
  (elpaca '(transient
            :host github
            :repo "magit/transient"
            :tag "v0.9.3"))

  (elpaca magit
    (autoload 'magit "magit")
    (bind-key "C-x g" 'magit))
#+end_src

*** Magit TODOs

Плагин который отлично выводит все *TODO* ключевые слова.

#+begin_src emacs-lisp
  (elpaca 'magit-todos
    (autoload 'magit-todos-mode "magit-todos")
    (add-hook 'magit-mode-hook 'magit-todos-mode))
#+end_src

*** Git файлы и режимы для них

#+begin_src emacs-lisp
  (elpaca 'git-modes
    (autoload 'gitignore-mode "git-modes")
    (autoload 'gitconfig-mode "git-modes")
    (autoload 'gitattributes-mode "git-modes")
    (setq auto-mode-alist
          (append
           '((".gitignore\\'" . gitignore-mode)
             (".gitconfig\\'" . gitconfig-mode)
             (".gitattributes\\'" . gitattributes-mode))
           auto-mode-alist)))
#+end_src

** REPL (Eat, Eshell)

Для эмуляции терминала я использую два пакета:
- =eshell= + =eat= - основной эмулятор терминала, который закрывает 90% задач (с режимами от =eat=)
- =eat= - эмулятор терминала закрывающий остальные 10%

*** Eshell

#+begin_src emacs-lisp
  (define-minor-mode eshell-mode-setup
  "Set up environment on `eshell-mode' invocation."
  :group 'eshell
  (if eshell-mode-setup
      (progn
        ;; FIXME: eshell throw error at `completion-at-point' with `all-the-icons-completion-mode' enabled.
        ;; This is just a temporary fix which disable it.
        (when (boundp 'all-the-icons-completion-mode)
          (all-the-icons-completion-mode 0))
        (if (and (boundp 'envrc-global-mode) envrc-global-mode)
            (add-hook 'envrc-mode-hook (lambda () (setenv "PAGER" "")))
          (setenv "PAGER" ""))
        (eshell/alias "l" "ls -al $1")
        (eshell/alias "e" "find-file $1")
        (eshell/alias "ee" "find-file-other-window $1")
        (eshell/alias "d" "dired $1")
        (eshell/alias "gd" "magit-diff-unstaged")
        ;; (local-unset-key 'eshell/clear)
        )
    (when (boundp 'all-the-icons-completion-mode)
      (all-the-icons-completion-mode 1))))
#+end_src

#+begin_src emacs-lisp
  (defun switch-to-prev-buffer-or-eshell (arg)
    (interactive "P")
    (if arg
        (eshell arg)			; or `project-eshell-or-eshell'
      (switch-to-buffer (other-buffer (current-buffer) 1))))

  (defun project-eshell-or-eshell (&optional arg)
    (interactive "P")
    (if (project-current)
        (project-eshell)
      (eshell arg)))
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load 'eshell
    (require 'em-alias)
    (require 'em-hist)
    
    (add-hook 'eshell-mode-hook 'eshell-mode-setup)

    (bind-key "s-e" 'switch-to-prev-buffer-or-eshell eshell-mode-map)
    (autoload 'consult-history "consult")
    (bind-key "M-r" 'consult-history eshell-hist-mode-map))

  (bind-key "s-e" 'project-eshell-or-eshell)
#+end_src

*** Eat (Emulate A Terminal)

#+begin_src emacs-lisp
  (defun project-eat-or-eat (&optional arg)
    (interactive "P")
    (if (project-current)
        (eat-project arg)
      (eat)))

  (defun switch-to-prev-buffer-or-eat (arg)
    (interactive "P")
    (if arg
        (eat nil arg)
      (switch-to-buffer (other-buffer (current-buffer) 1))))
#+end_src

#+begin_src emacs-lisp
  ;; Priority: nu (nushell) -> zsh -> fish -> bash -> babashka -> sh
  (setq-default eat-shell (or (executable-find "nu")   ; Nushell
                              (executable-find "zsh")  ; ZShell
                              (executable-find "fish") ; Like ZSH but simpler
                              (executable-find "bash") ; Default Bash
                              (executable-find "bb")   ; Clojure REPL (Without JVM)
                              (executable-find "sh"))) ; You don't have Bash !?

  (setq explicit-shell-file-name eat-shell)

  (setq-default eat-line-input-ring-size 1024
                eat-kill-buffer-on-exit t
                eat-term-scrollback-size nil
                eat-enable-mouse t)

  (elpaca 'eat
    (autoload 'eat "eat")
    (autoload 'eat-eshell-mode "eat")
    (autoload 'eat-eshell-visual-command-mode "eat")
    (bind-key "s-E" 'project-eat-or-eat)
    (add-hook 'eshell-load-hook 'eat-eshell-mode)
    (add-hook 'eshell-load-hook 'eat-eshell-visual-command-mode))

  (with-eval-after-load 'eat
    (bind-key "s-E" 'switch-to-prev-buffer-or-eat eat-mode-map))
#+end_src

** Languages

*** Emacs Lisp

#+begin_src emacs-lisp
  (elpaca 'highlight-defined
    (autoload 'highlight-defined-mode "highlight-defined")
    (add-hook 'emacs-lisp-mode-hook 'highlight-defined-mode))
#+end_src

*** Common Lisp

TODO: Setup completion with Corfu

#+begin_src emacs-lisp
  (setq-default inferior-lisp-program (executable-find "sbcl"))
  (elpaca 'sly)
#+end_src

*** Go + Tree-Sitter

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
  (add-to-list 'auto-mode-alist '("go.mod\\'" . go-mod-ts-mode))

  (elpaca 'ob-go
    (require-on! org-mode-hook
  	       ob-go))

  (defalias 'go-mode 'go-ts-mode)

  (after! 'go-ts-mode
    (setq go-ts-mode-indent-offset 4))
#+end_src
